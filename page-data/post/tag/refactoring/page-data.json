{"componentChunkName":"component---src-templates-posts-jsx","path":"/post/tag/refactoring","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"2f249d12-de77-5f0b-b4a2-560c9aa25d5d","html":"<p>신입땐 명세를 만족하는 코드를 빠르게 작성하는게 최고인 줄만 알았다.</p>\n<p>하지만 5년차쯤 되었을 때 이 생각에 문제가 있다는 것을 깨달았다.</p>\n<p>복잡한 요구사항을 만족하는 코드도 보기 좋게 작성할 수 있다.</p>\n<p>이 글에서 코드를 어떻게 작성해야 하는지에 대한 여러 생각들과 자료들을 정리해 본다.</p>\n<h2 id=\"불필요한-것들을-빼자\" style=\"position:relative;\"><a href=\"#%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%83%EB%93%A4%EC%9D%84-%EB%B9%BC%EC%9E%90\" aria-label=\"불필요한 것들을 빼자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불필요한 것들을 빼자</h2>\n<p>좋은 코드는 딱 필요한 만큼의 텍스트로만 작성되어 있다.</p>\n<p>한 파일 안에 함수만 있다고 우습게 볼 것이 아닌데, 그렇게 생각하는 개발자를 본 적이 있다.</p>\n<p>오히려 함수 하나면 되는데 클래스 이상을 동원하는 개발자가 이상한 것이다.</p>\n<p>함수 하나면 순수함수가 되는 경향이 있고. 테스트도 쉬워진다.</p>\n<p>이와 관련해서는 Kyle Simpson의 <a href=\"https://youtu.be/wJEX2FgNYLg\">The Economy of Keystrokes</a>를 보면 좋은데.</p>\n<p>키 스트로크는 돈과 같아서 가성비를 따져야 하고.</p>\n<p>사용한다면 가독성과 기능을 위해서만 사용해야 한다는 내용이다. 꼭 보길 바란다.</p>\n<h2 id=\"완성된-것들을-조합하자\" style=\"position:relative;\"><a href=\"#%EC%99%84%EC%84%B1%EB%90%9C-%EA%B2%83%EB%93%A4%EC%9D%84-%EC%A1%B0%ED%95%A9%ED%95%98%EC%9E%90\" aria-label=\"완성된 것들을 조합하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>완성된 것들을 조합하자</h2>\n<p>리눅스의 쉘은 수 많은 완성된 명령 행 도구를 조합 사용하여 목적을 달성하게 되어 있다.</p>\n<p>특정 파일들을 백업하는 경우 tar 명령어로 대상 파일들을 묶은 다음 ftp 명령어를 통해 업로드 한다.</p>\n<p>압축파일이 생성되어 있지 않다면? tar명령어의 문제일 것이다.</p>\n<p>압축파일은 있는데 업로드가 되지 않았다면? ftp를 포함한 네트워크의 문제일 것이다.</p>\n<p>각 도구들의 역할이 명확하기 때문에 현상만으로 대략적인 문제를 파악할 수 있다.</p>\n<p>이는 단위테스트가 추구하는 바 와도 일맥상통한다.</p>\n<p>만약 모든 기능을 한번에 수행하는 함수를 작성했다면 함수 전체를 라인단위로 디버깅해야 하는데.</p>\n<p>이런 코드가 많아질수록 유지보수하기 어렵게 된다. 아래 예제를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * path의 노드 중 pattern에 일치하는 노드들을 삭제함\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">deleteNodes</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path<span class=\"token punctuation\">,</span> pattern</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> dirent <span class=\"token keyword\">of</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">opendirSync</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dirent<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      fs<span class=\"token punctuation\">.</span><span class=\"token function\">unlinkSync</span><span class=\"token punctuation\">(</span>dirent<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드는 아래처럼 리펙토링 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * path의 하위 노드들을 조회함\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getNodes</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">opendirSync</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * pattern일치 노드를 제거함\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">deleteIfMatched</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> pattern</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">unlinkSync</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * path의 노드 중 pattern에 일치하는 노드들을 삭제함\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">deleteNodes</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">path<span class=\"token punctuation\">,</span> pattern</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> node <span class=\"token keyword\">of</span> <span class=\"token function\">getNodes</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">deleteIfMatched</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> pattern<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같은 방식의 리펙토링을 하면 다음과 같은 장점이 있다.</p>\n<ol>\n<li>\n<p>가독성</p>\n<ul>\n<li><em>리펙토링 이전:</em> 표현식과 문이 섞여 코드가 한 눈에 들어오지 않는다.</li>\n<li><em>리펙토링 이후:</em> 복잡한 식들이 적절한 이름의 메서드로 표현되어 마치 책을 읽는 것 처럼 코드가 읽힌다.</li>\n</ul>\n</li>\n<li>\n<p>테스트 용이성</p>\n<ul>\n<li><em>리펙토링 이전:</em> <code class=\"language-text\">deleteNodes</code>를 테스트하려면 한번에 여러 API Mock을 만들어야 하는 부담이 있다.</li>\n<li><em>리펙토링 이후:</em> getNodes는 NodeJS의 API를 단순히 이용할 뿐이므로. 테스트하지 않아도 된다. 하나의 메서드에 섞여있던 테스트 포인트가 <code class=\"language-text\">deleteIfMatched</code>, <code class=\"language-text\">deleteNodes</code>로 나뉘었다. 그리고 각 메서드를 테스트하기 위한 Mock제공이 상대적으로 덜 부담스럽다.</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li><em>리펙토링 이전:</em> <code class=\"language-text\">copyNodes</code>를 추가해야 한다면 리펙토링 이전은 주요 로직을 복사하고 요구사항에 맞게 수정해야 한다. 이 경우 전체 코드량이 2배가 되므로 테스트 커버리지가 감소한다.</li>\n<li><em>리펙토링 이후:</em> 비슷한 레벨의 <code class=\"language-text\">copyIfMatched</code> 함수와 <code class=\"language-text\">copyNodes</code>만 추가 구현하면 된다. 테스트 커버리지를 상대적으로 적게 감소시키며 코드를 확장할 수 있게 된다.</li>\n</ul>\n</li>\n</ol>\n<p>... 작성중입니다 ...</p>","frontmatter":{"categories":["development"],"tags":["refactoring"],"title":"좋은 코드를 작성하기 위한 생각들"},"fields":{"slug":"/post/좋은-코드를-위한-생각들","date":"2020-04-09T00:00:00.000+09:00"},"headings":[{"value":"불필요한 것들을 빼자","depth":2},{"value":"완성된 것들을 조합하자","depth":2}]}}]}},"pageContext":{"ids":["2f249d12-de77-5f0b-b4a2-560c9aa25d5d"],"pageNumber":0,"humanPageNumber":1,"skip":0,"limit":2,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}}}